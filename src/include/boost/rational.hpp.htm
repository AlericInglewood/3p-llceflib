<HTML>
<HEAD>
<TITLE>Auto-generated html formated source</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">
<P> </P>
<PRE><I><font color="#000080">//  Boost rational.hpp header file  ------------------------------------------//</font></I>

<I><font color="#000080">//  (C) Copyright Paul Moore 1999. Permission to copy, use, modify, sell and</font></I>
<I><font color="#000080">//  distribute this software is granted provided this copyright notice appears</font></I>
<I><font color="#000080">//  in all copies. This software is provided "as is" without express or</font></I>
<I><font color="#000080">//  implied warranty, and with no claim as to its suitability for any purpose.</font></I>

<I><font color="#000080">// boostinspect:nolicense (don't complain about the lack of a Boost license)</font></I>
<I><font color="#000080">// (Paul Moore hasn't been in contact for years, so there's no way to change the</font></I>
<I><font color="#000080">// license.)</font></I>

<I><font color="#000080">//  See http://www.boost.org/libs/rational for documentation.</font></I>

<I><font color="#000080">//  Credits:</font></I>
<I><font color="#000080">//  Thanks to the boost mailing list in general for useful comments.</font></I>
<I><font color="#000080">//  Particular contributions included:</font></I>
<I><font color="#000080">//    Andrew D Jewell, for reminding me to take care to avoid overflow</font></I>
<I><font color="#000080">//    Ed Brey, for many comments, including picking up on some dreadful typos</font></I>
<I><font color="#000080">//    Stephen Silver contributed the test suite and comments on user-defined</font></I>
<I><font color="#000080">//    IntType</font></I>
<I><font color="#000080">//    Nickolay Mladenov, for the implementation of operator+=</font></I>

<I><font color="#000080">//  Revision History</font></I>
<I><font color="#000080">//  05 Nov 06  Change rational_cast to not depend on division between different</font></I>
<I><font color="#000080">//             types (Daryle Walker)</font></I>
<I><font color="#000080">//  04 Nov 06  Off-load GCD and LCM to Boost.Math; add some invariant checks;</font></I>
<I><font color="#000080">//             add std::numeric_limits&lt;&gt; requirement to help GCD (Daryle Walker)</font></I>
<I><font color="#000080">//  31 Oct 06  Recoded both operator&lt; to use round-to-negative-infinity</font></I>
<I><font color="#000080">//             divisions; the rational-value version now uses continued fraction</font></I>
<I><font color="#000080">//             expansion to avoid overflows, for bug #798357 (Daryle Walker)</font></I>
<I><font color="#000080">//  20 Oct 06  Fix operator bool_type for CW 8.3 (Joaquín M López Muñoz)</font></I>
<I><font color="#000080">//  18 Oct 06  Use EXPLICIT_TEMPLATE_TYPE helper macros from Boost.Config</font></I>
<I><font color="#000080">//             (Joaquín M López Muñoz)</font></I>
<I><font color="#000080">//  27 Dec 05  Add Boolean conversion operator (Daryle Walker)</font></I>
<I><font color="#000080">//  28 Sep 02  Use _left versions of operators from operators.hpp</font></I>
<I><font color="#000080">//  05 Jul 01  Recode gcd(), avoiding std::swap (Helmut Zeisel)</font></I>
<I><font color="#000080">//  03 Mar 01  Workarounds for Intel C++ 5.0 (David Abrahams)</font></I>
<I><font color="#000080">//  05 Feb 01  Update operator&gt;&gt; to tighten up input syntax</font></I>
<I><font color="#000080">//  05 Feb 01  Final tidy up of gcd code prior to the new release</font></I>
<I><font color="#000080">//  27 Jan 01  Recode abs() without relying on abs(IntType)</font></I>
<I><font color="#000080">//  21 Jan 01  Include Nickolay Mladenov's operator+= algorithm,</font></I>
<I><font color="#000080">//             tidy up a number of areas, use newer features of operators.hpp</font></I>
<I><font color="#000080">//             (reduces space overhead to zero), add operator!,</font></I>
<I><font color="#000080">//             introduce explicit mixed-mode arithmetic operations</font></I>
<I><font color="#000080">//  12 Jan 01  Include fixes to handle a user-defined IntType better</font></I>
<I><font color="#000080">//  19 Nov 00  Throw on divide by zero in operator /= (John (EBo) David)</font></I>
<I><font color="#000080">//  23 Jun 00  Incorporate changes from Mark Rodgers for Borland C++</font></I>
<I><font color="#000080">//  22 Jun 00  Change _MSC_VER to BOOST_MSVC so other compilers are not</font></I>
<I><font color="#000080">//             affected (Beman Dawes)</font></I>
<I><font color="#000080">//   6 Mar 00  Fix operator-= normalization, #include &lt;string&gt; (Jens Maurer)</font></I>
<I><font color="#000080">//  14 Dec 99  Modifications based on comments from the boost list</font></I>
<I><font color="#000080">//  09 Dec 99  Initial Version (Paul Moore)</font></I>

<font color="#008040">#ifndef BOOST_RATIONAL_HPP</font>
<font color="#008040">#define BOOST_RATIONAL_HPP</font>

<font color="#008040">#include &lt;iostream&gt;              // for std::istream and std::ostream</font>
<font color="#008040">#include &lt;ios&gt;                   // for std::noskipws</font>
<font color="#008040">#include &lt;stdexcept&gt;             // for std::domain_error</font>
<font color="#008040">#include &lt;string&gt;                // for std::string implicit constructor</font>
<font color="#008040">#include &lt;boost/operators.hpp&gt;   // for boost::addable etc</font>
<font color="#008040">#include &lt;cstdlib&gt;               // for std::abs</font>
<font color="#008040">#include &lt;boost/call_traits.hpp&gt; // for boost::call_traits</font>
<font color="#008040">#include &lt;boost/config.hpp&gt;      // for BOOST_NO_STDC_NAMESPACE, BOOST_MSVC</font>
<font color="#008040">#include &lt;boost/detail/workaround.hpp&gt; // for BOOST_WORKAROUND</font>
<font color="#008040">#include &lt;boost/assert.hpp&gt;      // for BOOST_ASSERT</font>
<font color="#008040">#include &lt;boost/math/common_factor_rt.hpp&gt;  // for boost::math::gcd, lcm</font>
<font color="#008040">#include &lt;limits&gt;                // for std::numeric_limits</font>
<font color="#008040">#include &lt;boost/static_assert.hpp&gt;  // for BOOST_STATIC_ASSERT</font>

<I><font color="#000080">// Control whether depreciated GCD and LCM functions are included (default: yes)</font></I>
<font color="#008040">#ifndef BOOST_CONTROL_RATIONAL_HAS_GCD</font>
<font color="#008040">#define BOOST_CONTROL_RATIONAL_HAS_GCD  1</font>
<font color="#008040">#endif</font>

<B>namespace</B> boost {

<font color="#008040">#if BOOST_CONTROL_RATIONAL_HAS_GCD</font>
<B>template</B> &lt;<B>typename</B> IntType&gt;
IntType gcd(IntType n, IntType m)
{
    <I><font color="#000080">// Defer to the version in Boost.Math</font></I>
    <B>return</B> math::gcd( n, m );
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
IntType lcm(IntType n, IntType m)
{
    <I><font color="#000080">// Defer to the version in Boost.Math</font></I>
    <B>return</B> math::lcm( n, m );
}
<font color="#008040">#endif  // BOOST_CONTROL_RATIONAL_HAS_GCD</font>

<B>class</B> bad_rational : <B>public</B> std::domain_error
{
<B>public</B>:
    <B>explicit</B> bad_rational() : std::domain_error(<font color="#0000FF">"bad rational: zero denominator"</font>) {}
};

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>class</B> rational;

<B>template</B> &lt;<B>typename</B> IntType&gt;
rational&lt;IntType&gt; abs(<B>const</B> rational&lt;IntType&gt;&amp; r);

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>class</B> rational :
    less_than_comparable &lt; rational&lt;IntType&gt;,
    equality_comparable &lt; rational&lt;IntType&gt;,
    less_than_comparable2 &lt; rational&lt;IntType&gt;, IntType,
    equality_comparable2 &lt; rational&lt;IntType&gt;, IntType,
    addable &lt; rational&lt;IntType&gt;,
    subtractable &lt; rational&lt;IntType&gt;,
    multipliable &lt; rational&lt;IntType&gt;,
    dividable &lt; rational&lt;IntType&gt;,
    addable2 &lt; rational&lt;IntType&gt;, IntType,
    subtractable2 &lt; rational&lt;IntType&gt;, IntType,
    subtractable2_left &lt; rational&lt;IntType&gt;, IntType,
    multipliable2 &lt; rational&lt;IntType&gt;, IntType,
    dividable2 &lt; rational&lt;IntType&gt;, IntType,
    dividable2_left &lt; rational&lt;IntType&gt;, IntType,
    incrementable &lt; rational&lt;IntType&gt;,
    decrementable &lt; rational&lt;IntType&gt;
    &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
{
    <I><font color="#000080">// Class-wide pre-conditions</font></I>
    BOOST_STATIC_ASSERT( ::std::numeric_limits&lt;IntType&gt;::is_specialized );

    <I><font color="#000080">// Helper types</font></I>
    <B>typedef</B> <B>typename</B> boost::call_traits&lt;IntType&gt;::param_type param_type;

    <B>struct</B> helper { IntType parts[<font color="#0000A0">2</font>]; };
    <B>typedef</B> IntType (helper::* bool_type)[<font color="#0000A0">2</font>];

<B>public</B>:
    <B>typedef</B> IntType int_type;
    rational() : num(<font color="#0000A0">0</font>), den(<font color="#0000A0">1</font>) {}
    rational(param_type n) : num(n), den(<font color="#0000A0">1</font>) {}
    rational(param_type n, param_type d) : num(n), den(d) { normalize(); }

    <I><font color="#000080">// Default copy constructor and assignment are fine</font></I>

    <I><font color="#000080">// Add assignment from IntType</font></I>
    rational&amp; <B>operator</B>=(param_type n) { <B>return</B> assign(n, <font color="#0000A0">1</font>); }

    <I><font color="#000080">// Assign in place</font></I>
    rational&amp; assign(param_type n, param_type d);

    <I><font color="#000080">// Access to representation</font></I>
    IntType numerator() <B>const</B> { <B>return</B> num; }
    IntType denominator() <B>const</B> { <B>return</B> den; }

    <I><font color="#000080">// Arithmetic assignment operators</font></I>
    rational&amp; <B>operator</B>+= (<B>const</B> rational&amp; r);
    rational&amp; <B>operator</B>-= (<B>const</B> rational&amp; r);
    rational&amp; <B>operator</B>*= (<B>const</B> rational&amp; r);
    rational&amp; <B>operator</B>/= (<B>const</B> rational&amp; r);

    rational&amp; <B>operator</B>+= (param_type i);
    rational&amp; <B>operator</B>-= (param_type i);
    rational&amp; <B>operator</B>*= (param_type i);
    rational&amp; <B>operator</B>/= (param_type i);

    <I><font color="#000080">// Increment and decrement</font></I>
    <B>const</B> rational&amp; <B>operator</B>++();
    <B>const</B> rational&amp; <B>operator</B>--();

    <I><font color="#000080">// Operator not</font></I>
    <B>bool</B> <B>operator</B>!() <B>const</B> { <B>return</B> !num; }

    <I><font color="#000080">// Boolean conversion</font></I>
    
<font color="#008040">#if BOOST_WORKAROUND(__MWERKS__,&lt;=0x3003)</font>
    <I><font color="#000080">// The "ISO C++ Template Parser" option in CW 8.3 chokes on the</font></I>
    <I><font color="#000080">// following, hence we selectively disable that option for the</font></I>
    <I><font color="#000080">// offending memfun.</font></I>
<font color="#008040">#pragma parse_mfunc_templ off</font>
<font color="#008040">#endif</font>

    <B>operator</B> bool_type() <B>const</B> { <B>return</B> <B>operator</B> !() ? <font color="#0000A0">0</font> : &amp;helper::parts; }

<font color="#008040">#if BOOST_WORKAROUND(__MWERKS__,&lt;=0x3003)</font>
<font color="#008040">#pragma parse_mfunc_templ reset</font>
<font color="#008040">#endif</font>

    <I><font color="#000080">// Comparison operators</font></I>
    <B>bool</B> <B>operator</B>&lt; (<B>const</B> rational&amp; r) <B>const</B>;
    <B>bool</B> <B>operator</B>== (<B>const</B> rational&amp; r) <B>const</B>;

    <B>bool</B> <B>operator</B>&lt; (param_type i) <B>const</B>;
    <B>bool</B> <B>operator</B>&gt; (param_type i) <B>const</B>;
    <B>bool</B> <B>operator</B>== (param_type i) <B>const</B>;

<B>private</B>:
    <I><font color="#000080">// Implementation - numerator and denominator (normalized).</font></I>
    <I><font color="#000080">// Other possibilities - separate whole-part, or sign, fields?</font></I>
    IntType num;
    IntType den;

    <I><font color="#000080">// Representation note: Fractions are kept in normalized form at all</font></I>
    <I><font color="#000080">// times. normalized form is defined as gcd(num,den) == 1 and den &gt; 0.</font></I>
    <I><font color="#000080">// In particular, note that the implementation of abs() below relies</font></I>
    <I><font color="#000080">// on den always being positive.</font></I>
    <B>bool</B> test_invariant() <B>const</B>;
    <B>void</B> normalize();
};

<I><font color="#000080">// Assign in place</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::assign(param_type n, param_type d)
{
    num = n;
    den = d;
    normalize();
    <B>return</B> *<B>this</B>;
}

<I><font color="#000080">// Unary plus and minus</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt; <B>operator</B>+ (<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <B>return</B> r;
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt; <B>operator</B>- (<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <B>return</B> rational&lt;IntType&gt;(-r.numerator(), r.denominator());
}

<I><font color="#000080">// Arithmetic assignment operators</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::<B>operator</B>+= (<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <I><font color="#000080">// This calculation avoids overflow, and minimises the number of expensive</font></I>
    <I><font color="#000080">// calculations. Thanks to Nickolay Mladenov for this algorithm.</font></I>
    <I><font color="#000080">//</font></I>
    <I><font color="#000080">// Proof:</font></I>
    <I><font color="#000080">// We have to compute a/b + c/d, where gcd(a,b)=1 and gcd(b,c)=1.</font></I>
    <I><font color="#000080">// Let g = gcd(b,d), and b = b1*g, d=d1*g. Then gcd(b1,d1)=1</font></I>
    <I><font color="#000080">//</font></I>
    <I><font color="#000080">// The result is (a*d1 + c*b1) / (b1*d1*g).</font></I>
    <I><font color="#000080">// Now we have to normalize this ratio.</font></I>
    <I><font color="#000080">// Let's assume h | gcd((a*d1 + c*b1), (b1*d1*g)), and h &gt; 1</font></I>
    <I><font color="#000080">// If h | b1 then gcd(h,d1)=1 and hence h|(a*d1+c*b1) =&gt; h|a.</font></I>
    <I><font color="#000080">// But since gcd(a,b1)=1 we have h=1.</font></I>
    <I><font color="#000080">// Similarly h|d1 leads to h=1.</font></I>
    <I><font color="#000080">// So we have that h | gcd((a*d1 + c*b1) , (b1*d1*g)) =&gt; h|g</font></I>
    <I><font color="#000080">// Finally we have gcd((a*d1 + c*b1), (b1*d1*g)) = gcd((a*d1 + c*b1), g)</font></I>
    <I><font color="#000080">// Which proves that instead of normalizing the result, it is better to</font></I>
    <I><font color="#000080">// divide num and den by gcd((a*d1 + c*b1), g)</font></I>

    <I><font color="#000080">// Protect against self-modification</font></I>
    IntType r_num = r.num;
    IntType r_den = r.den;

    IntType g = math::gcd(den, r_den);
    den /= g;  <I><font color="#000080">// = b1 from the calculations above</font></I>
    num = num * (r_den / g) + r_num * den;
    g = math::gcd(num, g);
    num /= g;
    den *= r_den/g;

    <B>return</B> *<B>this</B>;
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::<B>operator</B>-= (<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <I><font color="#000080">// Protect against self-modification</font></I>
    IntType r_num = r.num;
    IntType r_den = r.den;

    <I><font color="#000080">// This calculation avoids overflow, and minimises the number of expensive</font></I>
    <I><font color="#000080">// calculations. It corresponds exactly to the += case above</font></I>
    IntType g = math::gcd(den, r_den);
    den /= g;
    num = num * (r_den / g) - r_num * den;
    g = math::gcd(num, g);
    num /= g;
    den *= r_den/g;

    <B>return</B> *<B>this</B>;
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::<B>operator</B>*= (<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <I><font color="#000080">// Protect against self-modification</font></I>
    IntType r_num = r.num;
    IntType r_den = r.den;

    <I><font color="#000080">// Avoid overflow and preserve normalization</font></I>
    IntType gcd1 = math::gcd(num, r_den);
    IntType gcd2 = math::gcd(r_num, den);
    num = (num/gcd1) * (r_num/gcd2);
    den = (den/gcd2) * (r_den/gcd1);
    <B>return</B> *<B>this</B>;
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::<B>operator</B>/= (<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <I><font color="#000080">// Protect against self-modification</font></I>
    IntType r_num = r.num;
    IntType r_den = r.den;

    <I><font color="#000080">// Avoid repeated construction</font></I>
    IntType zero(<font color="#0000A0">0</font>);

    <I><font color="#000080">// Trap division by zero</font></I>
    <B>if</B> (r_num == zero)
        <B>throw</B> bad_rational();
    <B>if</B> (num == zero)
        <B>return</B> *<B>this</B>;

    <I><font color="#000080">// Avoid overflow and preserve normalization</font></I>
    IntType gcd1 = math::gcd(num, r_num);
    IntType gcd2 = math::gcd(r_den, den);
    num = (num/gcd1) * (r_den/gcd2);
    den = (den/gcd2) * (r_num/gcd1);

    <B>if</B> (den &lt; zero) {
        num = -num;
        den = -den;
    }
    <B>return</B> *<B>this</B>;
}

<I><font color="#000080">// Mixed-mode operators</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt;&amp;
rational&lt;IntType&gt;::<B>operator</B>+= (param_type i)
{
    <B>return</B> <B>operator</B>+= (rational&lt;IntType&gt;(i));
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt;&amp;
rational&lt;IntType&gt;::<B>operator</B>-= (param_type i)
{
    <B>return</B> <B>operator</B>-= (rational&lt;IntType&gt;(i));
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt;&amp;
rational&lt;IntType&gt;::<B>operator</B>*= (param_type i)
{
    <B>return</B> <B>operator</B>*= (rational&lt;IntType&gt;(i));
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt;&amp;
rational&lt;IntType&gt;::<B>operator</B>/= (param_type i)
{
    <B>return</B> <B>operator</B>/= (rational&lt;IntType&gt;(i));
}

<I><font color="#000080">// Increment and decrement</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> <B>const</B> rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::<B>operator</B>++()
{
    <I><font color="#000080">// This can never denormalise the fraction</font></I>
    num += den;
    <B>return</B> *<B>this</B>;
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> <B>const</B> rational&lt;IntType&gt;&amp; rational&lt;IntType&gt;::<B>operator</B>--()
{
    <I><font color="#000080">// This can never denormalise the fraction</font></I>
    num -= den;
    <B>return</B> *<B>this</B>;
}

<I><font color="#000080">// Comparison operators</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>bool</B> rational&lt;IntType&gt;::<B>operator</B>&lt; (<B>const</B> rational&lt;IntType&gt;&amp; r) <B>const</B>
{
    <I><font color="#000080">// Avoid repeated construction</font></I>
    int_type <B>const</B>  zero( <font color="#0000A0">0</font> );

    <I><font color="#000080">// This should really be a class-wide invariant.  The reason for these</font></I>
    <I><font color="#000080">// checks is that for 2's complement systems, INT_MIN has no corresponding</font></I>
    <I><font color="#000080">// positive, so negating it during normalization keeps it INT_MIN, which</font></I>
    <I><font color="#000080">// is bad for later calculations that assume a positive denominator.</font></I>
    BOOST_ASSERT( <B>this</B>-&gt;den &gt; zero );
    BOOST_ASSERT( r.den &gt; zero );

    <I><font color="#000080">// Determine relative order by expanding each value to its simple continued</font></I>
    <I><font color="#000080">// fraction representation using the Euclidian GCD algorithm.</font></I>
    <B>struct</B> { int_type  n, d, q, r; }
     ts = { <B>this</B>-&gt;num, <B>this</B>-&gt;den, <B>static_cast</B>&lt;int_type&gt;(<B>this</B>-&gt;num / <B>this</B>-&gt;den),
     <B>static_cast</B>&lt;int_type&gt;(<B>this</B>-&gt;num % <B>this</B>-&gt;den) },
     rs = { r.num, r.den, <B>static_cast</B>&lt;int_type&gt;(r.num / r.den),
     <B>static_cast</B>&lt;int_type&gt;(r.num % r.den) };
    <B>unsigned</B>  reverse = <font color="#0000A0">0u</font>;

    <I><font color="#000080">// Normalize negative moduli by repeatedly adding the (positive) denominator</font></I>
    <I><font color="#000080">// and decrementing the quotient.  Later cycles should have all positive</font></I>
    <I><font color="#000080">// values, so this only has to be done for the first cycle.  (The rules of</font></I>
    <I><font color="#000080">// C++ require a nonnegative quotient &amp; remainder for a nonnegative dividend</font></I>
    <I><font color="#000080">// &amp; positive divisor.)</font></I>
    <B>while</B> ( ts.r &lt; zero )  { ts.r += ts.d; --ts.q; }
    <B>while</B> ( rs.r &lt; zero )  { rs.r += rs.d; --rs.q; }

    <I><font color="#000080">// Loop through and compare each variable's continued-fraction components</font></I>
    <B>while</B> ( <B>true</B> )
    {
        <I><font color="#000080">// The quotients of the current cycle are the continued-fraction</font></I>
        <I><font color="#000080">// components.  Comparing two c.f. is comparing their sequences,</font></I>
        <I><font color="#000080">// stopping at the first difference.</font></I>
        <B>if</B> ( ts.q != rs.q )
        {
            <I><font color="#000080">// Since reciprocation changes the relative order of two variables,</font></I>
            <I><font color="#000080">// and c.f. use reciprocals, the less/greater-than test reverses</font></I>
            <I><font color="#000080">// after each index.  (Start w/ non-reversed @ whole-number place.)</font></I>
            <B>return</B> reverse ? ts.q &gt; rs.q : ts.q &lt; rs.q;
        }

        <I><font color="#000080">// Prepare the next cycle</font></I>
        reverse ^= <font color="#0000A0">1u</font>;

        <B>if</B> ( (ts.r == zero) || (rs.r == zero) )
        {
            <I><font color="#000080">// At least one variable's c.f. expansion has ended</font></I>
            <B>break</B>;
        }

        ts.n = ts.d;         ts.d = ts.r;
        ts.q = ts.n / ts.d;  ts.r = ts.n % ts.d;
        rs.n = rs.d;         rs.d = rs.r;
        rs.q = rs.n / rs.d;  rs.r = rs.n % rs.d;
    }

    <I><font color="#000080">// Compare infinity-valued components for otherwise equal sequences</font></I>
    <B>if</B> ( ts.r == rs.r )
    {
        <I><font color="#000080">// Both remainders are zero, so the next (and subsequent) c.f.</font></I>
        <I><font color="#000080">// components for both sequences are infinity.  Therefore, the sequences</font></I>
        <I><font color="#000080">// and their corresponding values are equal.</font></I>
        <B>return</B> <B>false</B>;
    }
    <B>else</B>
    {
<font color="#008040">#ifdef BOOST_MSVC</font>
<font color="#008040">#pragma warning(push)</font>
<font color="#008040">#pragma warning(disable:4800)</font>
<font color="#008040">#endif</font>
        <I><font color="#000080">// Exactly one of the remainders is zero, so all following c.f.</font></I>
        <I><font color="#000080">// components of that variable are infinity, while the other variable</font></I>
        <I><font color="#000080">// has a finite next c.f. component.  So that other variable has the</font></I>
        <I><font color="#000080">// lesser value (modulo the reversal flag!).</font></I>
        <B>return</B> ( ts.r != zero ) != <B>static_cast</B>&lt;<B>bool</B>&gt;( reverse );
<font color="#008040">#ifdef BOOST_MSVC</font>
<font color="#008040">#pragma warning(pop)</font>
<font color="#008040">#endif</font>
    }
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>bool</B> rational&lt;IntType&gt;::<B>operator</B>&lt; (param_type i) <B>const</B>
{
    <I><font color="#000080">// Avoid repeated construction</font></I>
    int_type <B>const</B>  zero( <font color="#0000A0">0</font> );

    <I><font color="#000080">// Break value into mixed-fraction form, w/ always-nonnegative remainder</font></I>
    BOOST_ASSERT( <B>this</B>-&gt;den &gt; zero );
    int_type  q = <B>this</B>-&gt;num / <B>this</B>-&gt;den, r = <B>this</B>-&gt;num % <B>this</B>-&gt;den;
    <B>while</B> ( r &lt; zero )  { r += <B>this</B>-&gt;den; --q; }

    <I><font color="#000080">// Compare with just the quotient, since the remainder always bumps the</font></I>
    <I><font color="#000080">// value up.  [Since q = floor(n/d), and if n/d &lt; i then q &lt; i, if n/d == i</font></I>
    <I><font color="#000080">// then q == i, if n/d == i + r/d then q == i, and if n/d &gt;= i + 1 then</font></I>
    <I><font color="#000080">// q &gt;= i + 1 &gt; i; therefore n/d &lt; i iff q &lt; i.]</font></I>
    <B>return</B> q &lt; i;
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>bool</B> rational&lt;IntType&gt;::<B>operator</B>&gt; (param_type i) <B>const</B>
{
    <I><font color="#000080">// Trap equality first</font></I>
    <B>if</B> (num == i &amp;&amp; den == IntType(<font color="#0000A0">1</font>))
        <B>return</B> <B>false</B>;

    <I><font color="#000080">// Otherwise, we can use operator&lt;</font></I>
    <B>return</B> !<B>operator</B>&lt;(i);
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> <B>bool</B> rational&lt;IntType&gt;::<B>operator</B>== (<B>const</B> rational&lt;IntType&gt;&amp; r) <B>const</B>
{
    <B>return</B> ((num == r.num) &amp;&amp; (den == r.den));
}

<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> <B>bool</B> rational&lt;IntType&gt;::<B>operator</B>== (param_type i) <B>const</B>
{
    <B>return</B> ((den == IntType(<font color="#0000A0">1</font>)) &amp;&amp; (num == i));
}

<I><font color="#000080">// Invariant check</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> <B>bool</B> rational&lt;IntType&gt;::test_invariant() <B>const</B>
{
    <B>return</B> ( <B>this</B>-&gt;den &gt; int_type(<font color="#0000A0">0</font>) ) &amp;&amp; ( math::gcd(<B>this</B>-&gt;num, <B>this</B>-&gt;den) ==
     int_type(<font color="#0000A0">1</font>) );
}

<I><font color="#000080">// Normalisation</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>void</B> rational&lt;IntType&gt;::normalize()
{
    <I><font color="#000080">// Avoid repeated construction</font></I>
    IntType zero(<font color="#0000A0">0</font>);

    <B>if</B> (den == zero)
        <B>throw</B> bad_rational();

    <I><font color="#000080">// Handle the case of zero separately, to avoid division by zero</font></I>
    <B>if</B> (num == zero) {
        den = IntType(<font color="#0000A0">1</font>);
        <B>return</B>;
    }

    IntType g = math::gcd(num, den);

    num /= g;
    den /= g;

    <I><font color="#000080">// Ensure that the denominator is positive</font></I>
    <B>if</B> (den &lt; zero) {
        num = -num;
        den = -den;
    }

    BOOST_ASSERT( <B>this</B>-&gt;test_invariant() );
}

<B>namespace</B> detail {

    <I><font color="#000080">// A utility class to reset the format flags for an istream at end</font></I>
    <I><font color="#000080">// of scope, even in case of exceptions</font></I>
    <B>struct</B> resetter {
        resetter(std::istream&amp; is) : is_(is), f_(is.flags()) {}
        ~resetter() { is_.flags(f_); }
        std::istream&amp; is_;
        std::istream::fmtflags f_;      <I><font color="#000080">// old GNU c++ lib has no ios_base</font></I>
    };

}

<I><font color="#000080">// Input and output</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
std::istream&amp; <B>operator</B>&gt;&gt; (std::istream&amp; is, rational&lt;IntType&gt;&amp; r)
{
    IntType n = IntType(<font color="#0000A0">0</font>), d = IntType(<font color="#0000A0">1</font>);
    <B>char</B> c = <font color="#0000A0">0</font>;
    detail::resetter sentry(is);

    is &gt;&gt; n;
    c = is.get();

    <B>if</B> (c != <font color="#0000FF">'/'</font>)
        is.clear(std::istream::badbit);  <I><font color="#000080">// old GNU c++ lib has no ios_base</font></I>

<font color="#008040">#if !defined(__GNUC__) || (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3)) || defined __SGI_STL_PORT</font>
    is &gt;&gt; std::noskipws;
<font color="#008040">#else</font>
    is.unsetf(ios::skipws); <I><font color="#000080">// compiles, but seems to have no effect.</font></I>
<font color="#008040">#endif</font>
    is &gt;&gt; d;

    <B>if</B> (is)
        r.assign(n, d);

    <B>return</B> is;
}

<I><font color="#000080">// Add manipulators for output format?</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
std::ostream&amp; <B>operator</B>&lt;&lt; (std::ostream&amp; os, <B>const</B> rational&lt;IntType&gt;&amp; r)
{
    os &lt;&lt; r.numerator() &lt;&lt; <font color="#0000FF">'/'</font> &lt;&lt; r.denominator();
    <B>return</B> os;
}

<I><font color="#000080">// Type conversion</font></I>
<B>template</B> &lt;<B>typename</B> T, <B>typename</B> IntType&gt;
<B>inline</B> T rational_cast(
    <B>const</B> rational&lt;IntType&gt;&amp; src BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
{
    <B>return</B> <B>static_cast</B>&lt;T&gt;(src.numerator())/<B>static_cast</B>&lt;T&gt;(src.denominator());
}

<I><font color="#000080">// Do not use any abs() defined on IntType - it isn't worth it, given the</font></I>
<I><font color="#000080">// difficulties involved (Koenig lookup required, there may not *be* an abs()</font></I>
<I><font color="#000080">// defined, etc etc).</font></I>
<B>template</B> &lt;<B>typename</B> IntType&gt;
<B>inline</B> rational&lt;IntType&gt; abs(<B>const</B> rational&lt;IntType&gt;&amp; r)
{
    <B>if</B> (r.numerator() &gt;= IntType(<font color="#0000A0">0</font>))
        <B>return</B> r;

    <B>return</B> rational&lt;IntType&gt;(-r.numerator(), r.denominator());
}

} <I><font color="#000080">// namespace boost</font></I>

<font color="#008040">#endif  // BOOST_RATIONAL_HPP</font>

</PRE>
</BODY>

